### 基本特性-ACID

1. **原子性（Atomicity）**：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
2. **一致性（Consistent）**：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。
3. **隔离性（Isolation）**：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
4. **持久性（Durable）**：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

事务并发带来的问题
1. **丢失更新**:P字段初始值为0，A事务开始后将p字段+1，B事务未等待A事务提交也将p字段值更新并提交，A再事务提交，p最后的值是1，B的丢失更新，按照正常逻辑应该是A未提交时B先等待，A提交后B再开始事务并修改提交，此时的p应该为2。
2. **脏读**:一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”.，因为未提交的事务可能会回滚。
3. **不可重复读**:一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。其针对的是**update**
4. **幻读**:一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。其针对的是**insert**
### 事务隔离级别
在上面讲到的并发事务处理带来的问题中，“更新丢失”应该是要完全避免的，执行事务时必须要锁定对应的数据。
“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本上可分为以下两种。

1. 一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。
2. 另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)，这种技术叫做数据多版本并发控制（MultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库
* **当前读**

像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。

* **快照读**

像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本（此种情况下**可避免幻读**，但如果当前事务中存在加锁操作比如update操作，将仍然会出现幻读）

| 隔离级别                        | 脏读 | 不可重复读 | 幻读 |
| ------------------------------- | ---- | ---------- | ---- |
| 未提交读（Read uncommitted）    | Y    | Y          | Y    |
| 已提交读（Read committed）      | N    | Y          | Y    |
| 可重复读（Repeatable read）默认 | N    | N          | Y    |
| 可串行化（Serializable ）       | N    | N          | N    |

隔离级别及锁相关内容参考[MySQL InnoDB锁原理](https://www.cnblogs.com/z-dk/p/13236567.html)

#### ACID实现原理

##### 原子性Atomicity

实现原子性的关键是**当事务回滚时能够撤销所有已经成功执行的SQL语句**

> 当事务对数据库进行修改时，InnoDB会生成对应的 undo log；如果事务执行失败或调用了 rollback，导致事务需要回滚，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。

undo log 属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB 会根据 undo log 的内容做与之前相反的工作：

- 对于每个 insert，回滚时会执行 delete；
- 对于每个 delete，回滚时会执行insert；
- 对于每个 update，回滚时会执行一个相反的 update，把数据改回去。

以update操作为例：当事务执行update时，其生成的undo log中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到update之前的状态。

##### 持久性Durable

持久性靠的是 `redo log`

MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。

当有一条记录要更新时，InnoDB 引擎就会先把记录写到 redo log（并更新内存），这个时候更新就算完成了。在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。
redo log 有两个特点

- 大小固定，循环写
- crash-safe

对于redo log 是有两阶段的：commit 和 prepare
如果不使用“两阶段提交”，数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。

**Buffer Pool**:InnoDB还提供了缓存，Buffer Pool 中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：

- 当读取数据时，会先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；
- 当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中。

Buffer Pool 的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时 Buffer Pool 中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。**所以加入了 redo log**
当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。

如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。

redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。
而且这样做还有两个优点：

- 刷脏页是随机 IO，redo log 顺序 IO
- 刷脏页以Page为单位，一个Page上的修改整页都要写；而redo log 只包含真正需要写入的，无效 IO 减少。

**binlog和redolog**

- 层次：redo log 是 innoDB 引擎特有的，server 层的叫 binlog(归档日志)
- 内容：redolog 是物理日志，记录“在某个数据页上做了什么修改”；binlog 是逻辑日志，是语句的原始逻辑，如“给 ID=2 这一行的 c 字段加 1 ”
- 写入：redolog 循环写且写入时机较多，binlog 追加且在事务提交时写入

对于语句 `update T set c=c+1 where ID=2;`

1. 执行器先找引擎取 ID=2 这一行。ID 是主键，直接用树搜索找到。如果 ID = 2 这一行所在数据页就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成

为什么先写 redo log  ？

- 先 redo 后 bin : binlog 丢失，少了一次更新，恢复后仍是0。
- 先 bin 后 redo : 多了一次事务，恢复后是1。

##### 一致性**Consistent**

待补充