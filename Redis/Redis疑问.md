##### 为什么redis默认16个库,建议仅使用第一个库?

如果Redis各个库都有在使用，会有以下影响或者问题：

- **数据混乱**：如果不同的应用程序使用同一个Redis的不同库，那么就可能出现键名冲突的情况，导致数据被覆盖或者错误地读取。

  > 同一个Redis不同库会导致数据被覆盖数据混乱的原因是：
  >
  > - **键名冲突**：如果不同的应用程序使用同一个Redis的不同库，那么就可能出现相同的键名，比如user:1，这样就会导致一个应用程序的数据被另一个应用程序的数据覆盖或者错误地读取。
  > - **切换库不明显**：如果使用同一个Redis的不同库，那么就需要在命令之前指定库的编号，比如select 2，这样就可能造成切换库不明显，导致误操作或者混淆。
  > - **删除数据不安全**：如果使用同一个Redis的不同库，那么就需要注意删除数据的范围，比如flushdb只能删除该数据库中的数据，而flushall可以删除所有库中的数据，这样就可能造成误删或者数据丢失。

- **性能下降**：如果Redis的不同库都有大量的数据，那么就会占用更多的内存和CPU资源，影响Redis的响应速度和吞吐量。

- **难以管理**：如果Redis的不同库都有在使用，那么就需要对每个库进行单独的监控和维护，增加了管理的复杂度和成本。

##### Redis是什么？有什么特点？

Redis是一个开源的，基于内存的，支持多种数据结构的高性能的键值对数据库。它的特点有：速度快，支持丰富的数据类型，支持持久化，支持事务，支持发布订阅，支持主从复制，支持分布式集群等。

##### Redis有哪些数据类型？分别有什么应用场景？

| 数据类型         | 应用场景                   | 示例                           |
| ---------------- | -------------------------- | ------------------------------ |
| string           | 用来存储简单的键值对       | 用户信息，计数器，缓存等；     |
| list             | 存储有序的多个元素         | 消息队列，最新动态，排行榜等； |
| set              | 存储无序且不重复的多个元素 | 标签，好友关系，抽奖等；       |
| sorted set(zset) | 存储按照分数排序的多个元素 | 排行榜，延迟队列，定时任务等； |
| hash             | 存储多个字段和值的映射关系 | 用户信息，购物车，订单等。     |

##### Redis为何这么高的性能?

Redis 的 QPS 可以达到约 100000（每秒请求数）。

- Redis 是一个单线程的内存数据库，它的设计目的是为了提供高并发和快速响应。
- 由于 Redis 是基于内存的，内存的读写速度非常快，而且数据结构采用了 HashMap，查找和操作的时间复杂度都是 O(1)。
- 此外，由于 Redis 是单线程的，它省去了很多上下文切换线程的时间，避免了线程切换和竞态消耗
- Redis 的单线程设计可以支持高并发，主要是因为它采用了多路复用技术，可以处理并发的连接
- Redis 内部实现采用了 epoll，将读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，实现了高效的并发处理



##### Redis如何实现持久化？有什么优缺点？

Redis实现持久化有两种方式：rdb快照（snapshotting）和追加文件（append-only file）。

| 持久化方式  | 介绍                                         | 优点                                                 | 缺点                                                         |
| ----------- | -------------------------------------------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| RDB快照     | 定时将内存中的数据写入到磁盘上的二进制文件中 | 占用空间小，恢复速度快<br />适合做全量备份和灾难恢复 | 可能会丢失最近一次快照之后的数据,<br />生成快照时会影响性能和内存 |
| 追加文件AOF | 将每个写命令追加到磁盘上的文本文件中         | 数据完整性高，可以实现增量备份和还原                 | 占用空间大，恢复速度慢                                       |

RDB：RDB是指将内存中的数据定时或者手动地写入到磁盘上的二进制文件中，这个文件可以用来备份或者迁移数据。RDB有两种持久化方式：手动触发和自动触发。手动触发使用以下两个命令：

- **save**：会阻塞当前Redis服务器响应其他命令，直到RDB快照生成完成为止，对于内存比较大的实例会造成长时间阻塞，所以线上环境不建议使用。
- **bgsave**：Redis会创建一个子进程来生成RDB快照，父进程不会阻塞，但是会影响内存分配和复制性能，所以也不适合频繁使用。

自动触发是通过配置文件中的save参数来设置，在一定时间内满足一定数量的写操作就会触发bgsave命令。

AOF：AOF是指将每个写命令追加到磁盘上的文本文件中，这个文件可以用来记录所有的写操作历史。AOF有三种同步策略：

- **always**：每个写命令都会同步到磁盘上，这样可以保证数据完整性，但是会影响性能和寿命。
- **everysec**：每秒钟同步一次写命令到磁盘上，这样可以平衡数据完整性和性能，是**默认的策略**。
- **no**：由操作系统决定何时同步写命令到磁盘上，这样可以提高性能，但是可能会丢失很多数据。

AOF还有一个重写机制，就是当AOF文件过大时，Redis会创建一个子进程来根据内存中的数据生成一个新的AOF文件，并且在生成过程中仍然可以追加新的写命令。